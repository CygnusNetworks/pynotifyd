#!/usr/bin/env python
# -*- coding: utf-8 -*-

# The following snippet has to occur before anyone uses the logging module.
try:
	import pyinotify
except ImportError:
	pass
else:
	# Now pyinoty has called its log_init and fucked the GLOBAL LOGGER CLASS.
	import logging
	logging.setLoggerClass(logging.Logger)

import pynotifyd
import pynotifyd.queue
import pynotifyd.providers.all
import logging
import logging.handlers
from optparse import OptionParser
import sys
import os
import signal
import grp
import pwd
try:
	from setproctitle import setproctitle
except ImportError:
	def setproctitle(_):
		die("Cannot set process title: setproctitle module not found.")

logger = logging.getLogger("pynotifyd.daemon")

def logstderr(message):
	sys.stderr.write(message + "\n")

def die(message):
	logstderr(message)
	sys.exit(1)

def die_exc(exception):
	die("error: %s" % str(exception))

def partial_apply(function, *boundargs, **boundkwargs):
	def wrapped_function(*args, **kwargs):
		newargs = boundargs + args
		newkwargs = boundkwargs.copy()
		boundkwargs.update(kwargs)
		return function(*newargs, **newkwargs)
	wrapped_function.__doc__ = function.__doc__
	return wrapped_function

def daemonize():
	rend, wend = os.pipe()
	rend = os.fdopen(rend, "r")
	wend = os.fdopen(wend, "w")
	os.chdir("/")
	devnull = os.open("/dev/null", os.O_RDWR)
	os.dup2(devnull, 0)
	os.dup2(devnull, 1)
	# Redirect stderr later, so we can use it for die.
	try:
		if os.fork() > 0:
			wend.close()
			data = rend.read()
			if data:
				sys.stderr.write(data)
				sys.exit(1)
			sys.exit(0)
	except OSError, e:
		die("first fork failed")
	os.setsid()
	try:
		if os.fork() > 0:
			sys.exit(0)
	except OSError, e:
		die("second fork failed")
	rend.close()
	os.dup2(devnull, 2)
	return wend

def chgid(group):
	if group.isdigit():
		group = int(group)
	else:
		try:
			group = grp.getgrnam(group).gr_gid
		except KeyError:
			die("group %r not found" % group)
	try:
		os.setgid(group)
	except OSError, err:
		die_exc(err)
	if os.getgid() != group:
		die("gid unchanged after setgid()")

def chuid(user):
	if user.isdigit():
		user = int(user)
	else:
		try:
			user = pwd.getpwnam(user).pw_uid
		except KeyError:
			die("user %r not found" % user)
	try:
		os.setuid(user)
	except OSError, err:
		die_exc(err)
	if os.getuid() != user:
		die("uid unchanged after setuid()")

def syslog_handler(ident):
	sysloghand = logging.handlers.SysLogHandler(address="/dev/log")
	logformat = "%s[%%(process)s]: %%(message)s" % (ident,)
	sysloghand.setFormatter(logging.Formatter(logformat))
	return sysloghand

def main():
	def_config = "/etc/pynotifyd.conf"
	parser = OptionParser(usage="Usage: %prog [options]")
	parser.add_option("-c", "--config", dest="configfile", default=def_config,
			help="use FILE as configuration file", metavar="FILE")
	parser.add_option("-f", "--foreground", dest="foreground", default=False,
			help="do not fork into background", action="store_true")
	parser.add_option("--clearqueue", dest="clearqueue", default=False,
			help="clear the queue prior to starting up", action="store_true")
	parser.add_option("--debuglibs", default=False, dest="debuglibs",
			help="include very verbose log message from all libraries employed",
			action="store_true")
	options, args = parser.parse_args()

	mainlogger = logging.getLogger(None if options.debuglibs else "pynotifyd")
	mainlogger.setLevel(logging.DEBUG)
	if options.foreground:
		mainlogger.addHandler(logging.StreamHandler(sys.stderr))
	else:
		mainlogger.addHandler(syslog_handler("pynotifyd"))

	if args:
		die("unrecognized non-option parameters were passed")

	try:
		config = pynotifyd.read_config(options.configfile)
	except pynotifyd.PyNotifyDError, err:
		die_exc(err)

	if "chgid" in config["general"]:
		chgid(config["general"]["chgid"])
	if "chuid" in config["general"]:
		chuid(config["general"]["chuid"])

	if config["general"]["notify"] == "inotify":
		dw = pynotifyd.InotifyDirectoryWatcher
	elif config["general"]["notify"] == "signal":
		dw = pynotifyd.SignalDirectoryWatcher
	else:
		die("unknown notify method %r" % config["general"]["notify"])

	if not options.foreground:
		old_stderr = sys.stderr
		sys.stderr = daemonize()

	try:
		queue = pynotifyd.queue.PersistentQueue(config["general"]["queuedir"],
				config["general"]["retry"])

		providers = {}
		for name, section in config["providers"].items():
			try:
				providers[name] = pynotifyd.providers.all.provider_drivers \
						[section["driver"]](section)
			except pynotifyd.PyNotifyDError, err:
				err.args = err.args + ("in provider %s" % name,)
				raise err
	except pynotifyd.PyNotifyDError, err:
		die_exc(err)

	if config["general"].get("proctitle"):
		setproctitle(config["general"]["proctitle"])

	dw = dw(config["general"]["queuedir"])

	try:
		queue.lock()
		if options.clearqueue:
			queue.clear()
	except pynotifyd.PyNotifyDError, err:
		die_exc(err)

	# startup finished: terminate parent
	if not options.foreground:
		sys.stderr.close()
		sys.stderr = old_stderr

	try:
		running = [True]
		def terminate(signum, frame):
			running[0] = False
		signal.signal(signal.SIGTERM, terminate)
		while running[0]:
			logger.debug("processing next event")
			wait = pynotifyd.queue.process_queue_step(config, queue, providers)
			if wait == 0:
				continue
			if wait is None:
				logger.debug("queue empty, sleeping ")
			else:
				logger.debug("sleeping up to %.1f seconds" % wait)
			dw(wait)
		logger.debug("terminating due to SIGTERM")
	finally:
		for name, provider in providers.items():
			logger.debug("terminating provider %s" % name)
			try:
				provider.terminate()
			except Exception, exc:
				logger.error("failed to terminate provider %s with %s: %s" %
						(name, exc.__class__.__name__, str(exc)))
		queue.unlock()

if __name__ == '__main__':
	try:
		main()
	except Exception, exc:
		logger.error("pynotifyd crashed with exception %s: %s" %
				(exc.__class__.__name__, str(exc)))
		raise
